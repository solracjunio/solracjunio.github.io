---
layout: single
title: "# ECS vs POO: Por que a OrientaÃ§Ã£o a Objetos NÃ£o Funciona TÃ£o Bem em Jogos"
date: 2025-06-19
---

> "HeranÃ§a mÃºltipla com 10 nÃ­veis de subclasses, cÃ³digo espaguete, performance patÃ©tica... isso Ã© o que vocÃª ganha tentando fazer jogo com POO pura."
> â€“ alguÃ©m que tentou e falhou

---

### ğŸ“œ Um pouco de histÃ³riaâ€¦

Se vocÃª programou nos anos 90 ou 2000, **POO** (ProgramaÃ§Ã£o Orientada a Objetos) era o evangelho. Todo mundo batia na tecla de â€œencapsulamento, heranÃ§a e polimorfismoâ€. E com razÃ£o! Para software tradicional â€“ como sistemas de gestÃ£o, bancos ou e-commerce â€“ a POO fez maravilhas.

Masâ€¦ quando o assunto Ã© **jogos**, as coisas nÃ£o sÃ£o tÃ£o simples.

---

### ğŸ® O problema com jogos

Jogos sÃ£o um caos.

VocÃª tem milhares de objetos interagindo ao mesmo tempo: projÃ©teis, partÃ­culas, inimigos, jogadores, itens no chÃ£o, Ã¡rvores que pegam fogo, sistemas climÃ¡ticos dinÃ¢micos, IA, fÃ­sicaâ€¦

Tentar controlar tudo isso com uma **Ã¡rvore de heranÃ§a tradicional** Ã© como tentar segurar um polvo com luvas de boxe.

Imagine:

```cpp
class Inimigo {
    void mover();
    void atacar();
}

class InimigoVoando : Inimigo {
    void voar();
}

class InimigoComEscudo : Inimigo {
    void defender();
}

class InimigoVoandoComEscudo : InimigoVoando, InimigoComEscudo {
    // caos absoluto
}
```

Daqui a pouco vocÃª tem classes como `InimigoComArmaduraQueVoaAtiraSeEscondeQuandoChove`. Boa sorte mantendo isso.

---

### ğŸ’¡ A virada: ECS

Foi aÃ­ que surgiram arquiteturas como o **ECS â€“ Entity Component System**.

Primeiro popularizado em engines como **Unity**, mas inspirado por ideias anteriores de **Data-Oriented Design**, o ECS muda completamente a forma de pensar.

Ele parte de uma ideia radical:

> â€œ**HeranÃ§a Ã© um problema. Separar dados de lÃ³gica Ã© a soluÃ§Ã£o.**â€

---

### ğŸ§© Como funciona o ECS?

Em vez de classes, vocÃª tem:

* **Entities (Entidades)** â†’ sÃ£o apenas IDs, como `42`, `102`, etc.
* **Components (Componentes)** â†’ sÃ£o *dados puros*. Ex: `Vida(100)`, `PosiÃ§Ã£o(x=10, y=5)`, `Velocidade(3.5)`
* **Systems (Sistemas)** â†’ sÃ£o funÃ§Ãµes que **processam dados**. Ex: `SistemaDeMovimento`, `SistemaDeCombate`

Ã‰ como montar Lego:

```plaintext
[ Entidade #001 ]
- Componente: Vida(100)
- Componente: PosiÃ§Ã£o(0,0)
- Componente: Velocidade(5)
```

O sistema de movimento pega todas as entidades com `PosiÃ§Ã£o` + `Velocidade` e as move. Simples, direto, performÃ¡tico.

Sem heranÃ§a. Sem acoplamento. Sem dor de cabeÃ§a.

---

### ğŸš€ Por que ECS Ã© melhor para jogos?

Vamos ser diretos.

**1. Performance absurda.**
Como os componentes sÃ£o dados puros, vocÃª pode armazenÃ¡-los em arrays contÃ­guos na memÃ³ria. Isso significa **cache-friendly**, **simd-friendly**, **multithread-friendly**. Lembra da sua IA travando quando tinha 500 inimigos? ECS nÃ£o sofre disso.

**2. ComposiÃ§Ã£o em vez de heranÃ§a.**
Quer que uma entidade voe? Adiciona `ComponentePodeVoar`. Quer que pare de voar? Remove. Sem precisar herdar nada.

**3. SeparaÃ§Ã£o de responsabilidades.**
Se vocÃª estudou Clean Architecture ou DDD, sabe o valor de separar dados de lÃ³gica. ECS leva isso ao extremo.

**4. Escalabilidade real.**
Projetos grandes com dezenas de sistemas e centenas de tipos de entidades se mantÃªm organizados, testÃ¡veis e eficientes.

---

### ğŸ¤” Mas por que ainda usam POO?

Por inÃ©rcia. Porque Ã© o que se ensina. Porque Ã© mais fÃ¡cil de entender no comeÃ§o. Porque funciona *atÃ© certo ponto*.

Mas, com o tempo, a conta chega. O cÃ³digo vira uma cebola: camadas e camadas de heranÃ§a e gambiarra tentando adaptar comportamentos emergentes.

---

### ğŸ“ A liÃ§Ã£o de design

A verdadeira liÃ§Ã£o aqui nÃ£o Ã© â€œPOO Ã© ruimâ€. NÃ£o Ã©. POO Ã© Ã³timo em muitos contextos. Mas **em jogos**, a composiÃ§Ã£o supera a heranÃ§a quase sempre.

ECS Ã© uma forma prÃ¡tica de aplicar essa filosofia.

---

### ğŸ“š Para se aprofundar:

* [Game Programming Patterns â€“ Robert Nystrom](https://gameprogrammingpatterns.com/component.html)
* Engines como [Bevy (Rust)](https://bevyengine.org/) e [Flecs (C++)](https://github.com/SanderMertens/flecs)
* Palestra do Ryan Hipple onde aborda Scriptable Objects que pode servir para guardar os dados (Components)
{% include video id="raQ3iHhE_Kk" provider="youtube" %}


---

### ğŸ’¬ ConclusÃ£o

Se vocÃª quer fazer jogos **mais performÃ¡ticos**, **mais escalÃ¡veis**, e **mais flexÃ­veis**, aprenda ECS.
No comeÃ§o parece complicado. Mas depois que vocÃª entende, volta para POO sÃ³ em Ãºltimo caso.

E lembra: **"favor composiÃ§Ã£o ao invÃ©s de heranÃ§a"** nÃ£o Ã© sÃ³ uma frase bonita. Ã‰ um grito de socorro vindo de quem jÃ¡ manteve 10 mil linhas de cÃ³digo acoplado por subclasses demais.
